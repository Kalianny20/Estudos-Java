<h1 align="center">
  <img src="https://readme-typing-svg.herokuapp.com?font=Righteous&size=40&duration=4000&pause=1000&color=0098D1&center=true&vCenter=true&random=false&width=435&lines=üîé+Estudos+de+Java!!!;" />
</h1>

<h2 align="center">
  <img src="https://media1.tenor.com/m/xv-8Q_TJne4AAAAC/java.gif"/>
</h2>

</br> 

<p align="center">
  üöÄ Bem-vindo ao meu reposit√≥rio dedicado aos estudos em Orienta√ß√£o a Objetos com Java! Aqui, compartilho minha jornada de aprendizado por meio de um desafio de 100 dias, onde me comprometo a programar diariamente e aprofundar meus conhecimentos em POO. Este espa√ßo ser√° constantemente atualizado com novos projetos, exemplos e insights, ent√£o fique √† vontade para acompanhar minha evolu√ß√£o. üíª‚ú®
</p>


</br>

<h1 align="center"> üçÄ Dia 1 </h1>

<h2>üéì Introdu√ß√£o √† Tecnologia de Objetos </h2>

Hoje, como a demanda por software novo e mais poderoso est√° aumentando, construir softwares de maneira r√°pida, correta e econ√¥mica continua a ser um objetivo indefinido. Objetos ou, mais precisamente, as classes de onde os objetos v√™m s√£o essencialmente componentes reutiliz√°veis de software. H√° objetos data, objetos data/hora, objetos √°udio, objetos v√≠deo, objetos autom√≥vel, objetos pessoas etc. Quase qualquer substantivo pode ser razoavelmente representado como um objeto de software em termos dos atributos (por exemplo, nome, cor e tamanho) e comportamentos (por exemplo, calcular, mover e comunicar). Grupos de desenvolvimento de software podem usar uma abordagem modular de projeto e implementa√ß√£o orientados a objetos para que sejam muito mais produtivos do que com as t√©cnicas anteriormente populares como ‚Äúprograma√ß√£o estruturada‚Äù ‚Äî programas orientados a objetos s√£o muitas vezes mais f√°ceis de entender, corrigir e modificar.

</br>

<h2>üöò O Autom√≥vel como um Objeto </h2>

- **Analogia com Carro:**
  - Para facilitar a compreens√£o de objetos e seus conte√∫dos, vamos usar uma analogia com um carro.
  - Imagine que voc√™ queira dirigir um carro e aceler√°-lo pisando no pedal do acelerador.

- **Projeto do Carro:**
  - Antes de ser poss√≠vel dirigir um carro, ele precisa ser projetado.
  - Um carro come√ßa como desenhos de engenharia, semelhantes a plantas que descrevem o projeto de uma casa.
  - Esses desenhos incluem o projeto do pedal do acelerador.

- **Oculta√ß√£o dos Mecanismos:**
  - Assim como o pedal do acelerador esconde do motorista os mecanismos que fazem o carro ir mais r√°pido, outros componentes como o pedal de freio e a dire√ß√£o tamb√©m ocultam seus mecanismos.
  - Isso torna poss√≠vel para pessoas com pouco conhecimento t√©cnico dirigirem um carro facilmente.

- **Constru√ß√£o do Carro:**
  - Antes de ser poss√≠vel dirigir um carro, ele precisa ser constru√≠do a partir dos desenhos de engenharia que o descrevem.
  - Um carro pronto tem um pedal de acelerador real para faz√™-lo andar mais r√°pido.
  - No entanto, o carro n√£o acelerar√° por conta pr√≥pria; o motorista deve pressionar o pedal do acelerador.

</br> 

<h2> üîó M√©todos e Classes</h2>

- **Classes:**
  - Em Java, as classes s√£o a base da programa√ß√£o orientada a objetos (POO).
  - Uma classe √© um modelo ou um plano para criar objetos.
  - Define os atributos e comportamentos comuns que os objetos compartilham.
  - Exemplo: uma classe `Carro` pode ter atributos como `marca`, `modelo` e `cor`, e m√©todos como `ligar()`, `desligar()` e `acelerar()`.

- **M√©todos:**
  - Os m√©todos em Java s√£o fun√ß√µes ou procedimentos associados a uma classe.
  - Definem o comportamento dos objetos criados a partir dessa classe.
  - Podem realizar opera√ß√µes, acessar ou modificar atributos e interagir com outros objetos.
  - Encapsulam a l√≥gica de como um objeto deve se comportar e interagir com o mundo exterior.
  - Exemplo: um m√©todo `ligar()` na classe `Carro` muda o estado do carro de desligado para ligado.

- **Combina√ß√£o de Classes e M√©todos:**
  - Permite a cria√ß√£o de c√≥digo modular e reutiliz√°vel.
  - As classes definem a estrutura e o comportamento dos objetos.
  - Os m√©todos encapsulam a funcionalidade espec√≠fica.
  - Promove a organiza√ß√£o do c√≥digo, facilitando a manuten√ß√£o e a extens√£o do sistema.


<h2> üíª Exerc√≠cio</h2>

### ‚û°Ô∏è Pasta "Classes"

Esta pasta cont√©m o seguinte programa Java:

### Programa de C√°lculo de √Årea de Tri√¢ngulos

O arquivo `Program.java` √© um programa Java que calcula a √°rea de dois tri√¢ngulos e determina qual deles tem a maior √°rea. O programa consiste em duas classes:

1. **Classe `Program`**:
   - Esta classe √© a classe principal do programa e cont√©m o m√©todo `main`, que √© o ponto de entrada do programa.
   - No m√©todo `main`, s√£o realizadas as seguintes opera√ß√µes:
     - Configura√ß√£o do local padr√£o para formata√ß√£o de n√∫meros.
     - Cria√ß√£o de um objeto `Scanner` para receber entrada do usu√°rio.
     - Declara√ß√£o de dois objetos `Triangle` para representar os tri√¢ngulos.
     - Solicita√ß√£o ao usu√°rio para inserir as medidas dos lados dos tri√¢ngulos.
     - C√°lculo das √°reas dos tri√¢ngulos e determina√ß√£o do tri√¢ngulo com a maior √°rea.
     - Impress√£o das √°reas dos tri√¢ngulos e da mensagem indicando qual tem a maior √°rea.

2. **Classe `Triangle`**:
   - Esta classe define a estrutura de um tri√¢ngulo com tr√™s atributos para os comprimentos dos lados (`a`, `b` e `c`).
   - Possui um m√©todo `area()` que calcula a √°rea do tri√¢ngulo usando a f√≥rmula de Her√£o.

- O programa √© estruturado em pacotes: o pacote `application` cont√©m a classe `Program`, e o pacote `entities` cont√©m a classe `Triangle`.

- Esse foi um exerc√≠cio feito para colocar em pr√°tica os conceitos de `Classes`  e `M√©todos` .

 ---
</br>
 
<h1 align="center"> üçÄ Dia 2 </h1>

## üîó Par√¢metros e Argumentos

Em orienta√ß√£o a objetos, "par√¢metros" e "argumentos" s√£o termos frequentemente usados em conjunto, mas referem-se a conceitos diferentes.

1. **Par√¢metros**: S√£o vari√°veis definidas na declara√ß√£o de um m√©todo ou fun√ß√£o. Eles servem como marcadores de posi√ß√£o para os valores que ser√£o passados quando o m√©todo ou fun√ß√£o for chamado. Os par√¢metros definem quais tipos de valores uma fun√ß√£o espera receber e como esses valores ser√£o usados dentro dela.

   Exemplo:
   ```java
   public class Exemplo {
       // M√©todo que recebe dois par√¢metros e retorna a soma
       public static int soma(int a, int b) {
           return a + b;
       }

       public static void main(String[] args) {
           // Chamando o m√©todo soma e passando os argumentos 3 e 5
           int resultado = soma(3, 5);
           System.out.println("Resultado da soma: " + resultado);
       }
   }
   ```

   Neste exemplo, temos um m√©todo chamado `soma` que recebe dois par√¢metros `a` e `b`, e retorna a soma desses dois par√¢metros. No m√©todo `main`, estamos chamando o m√©todo `soma` e passando os argumentos `3` e `5`. Quando o m√©todo √© chamado com esses argumentos, `a` ser√° igual a `3` e `b` ser√° igual a `5`. O resultado da soma ser√° impresso no console.

3. **Argumentos**: S√£o os valores reais que s√£o passados para uma fun√ß√£o ou m√©todo quando ele √© chamado. Eles preenchem os par√¢metros definidos na declara√ß√£o da fun√ß√£o. Em outras palavras, s√£o os valores que voc√™ fornece para que a fun√ß√£o os utilize durante sua execu√ß√£o.

   Exemplo:
   ```java
   public class Exemplo {
       // M√©todo que recebe dois par√¢metros e retorna a soma
       public static int soma(int a, int b) {
           return a + b;
       }

       public static void main(String[] args) {
           // Chamando o m√©todo soma e passando os argumentos 3 e 5
           int resultado = soma(3, 5);
           System.out.println("Resultado da soma: " + resultado);
       }
   }
   ```

   Neste exemplo, temos um m√©todo chamado `soma` que recebe dois par√¢metros `a` e `b`, e retorna a soma desses dois par√¢metros. No m√©todo `main`, estamos chamando o m√©todo `soma` e passando os argumentos `3` e `5`. Quando o m√©todo √© chamado com esses argumentos, `a` ser√° igual a `3` e `b` ser√° igual a `5`. O resultado da soma ser√° impresso no console.

Resumindo, os par√¢metros s√£o as vari√°veis na declara√ß√£o de uma fun√ß√£o que definem quais valores ela espera receber, enquanto os argumentos s√£o os valores reais fornecidos quando a fun√ß√£o √© chamada para preencher esses par√¢metros.

 
<h2> üíª Exerc√≠cio</h2>

### ‚û°Ô∏è Pasta "Classes2"

Esta pasta cont√©m o seguinte programa Java:

### Programa de Controle de Produtos

1. **Classe Program:**
   - Esta √© a classe principal do programa, contendo o m√©todo `main` como ponto de entrada.
   - No m√©todo `main`, as seguintes opera√ß√µes s√£o realizadas:
     - Configura√ß√£o do local padr√£o para formata√ß√£o de n√∫meros decimais para o estilo dos EUA.
     - Cria√ß√£o de um objeto `Scanner` para receber entrada do usu√°rio.
     - Cria√ß√£o de um objeto `Product` para representar o produto inserido pelo usu√°rio.
     - Solicita√ß√£o ao usu√°rio para inserir os dados do produto, incluindo nome, pre√ßo e quantidade em estoque.
     - Exibi√ß√£o dos detalhes do produto utilizando o m√©todo `toString()` da classe `Product`.
     - Fechamento do objeto `Scanner` para liberar os recursos.

2. **Classe Product:**
   - Esta classe representa um produto com tr√™s atributos: `name` (nome), `price` (pre√ßo) e `quantity` (quantidade em estoque).
   - Possui m√©todos para calcular o valor total em estoque do produto (`totalValueInStock()`), adicionar produtos ao estoque (`addProducts()`) e remover produtos do estoque (`removeProducts()`).
   - O m√©todo `toString()` √© sobrescrito para fornecer uma representa√ß√£o personalizada do objeto `Product`, exibindo o nome, pre√ßo, quantidade em estoque e o valor total em estoque formatado.

O programa √© organizado em dois arquivos Java, onde a classe `Program` est√° no pacote `application` e a classe `Product` est√° no pacote `entities`.

</br>

## üîó M√©todo toString()
- O m√©todo `toString` em Java √© essencial para criar representa√ß√µes textuais de objetos.
- Toda classe em Java √© automaticamente uma filha da classe `Object`, que possui o m√©todo `toString`.
- A implementa√ß√£o padr√£o de `toString` em `Object` retorna "nomeDaClasse@endere√ßoNaMem√≥ria".
- √â poss√≠vel personalizar a representa√ß√£o textual de um objeto ao sobrescrever o m√©todo `toString`.
- Por exemplo, ao sobrescrever `toString` na classe `Pessoa`, podemos retornar uma representa√ß√£o que inclui CPF e nome.
- Isso oferece flexibilidade para controlar como os objetos s√£o representados textualmente.
- `toString` facilita a depura√ß√£o e a compreens√£o do c√≥digo, fornecendo uma representa√ß√£o leg√≠vel do objeto em forma de texto.

    Exemplo:
    ```java
    public class Pessoa {
    private String nome;
    private String cpf;

    // Construtor
    public Pessoa(String nome, String cpf) {
        this.nome = nome;
        this.cpf = cpf;
    }

    // Sobrescrevendo o m√©todo toString para personalizar a representa√ß√£o textual
    @Override
    public String toString() {
        return "Pessoa{ nome='" + nome + "', cpf='" + cpf + "' }";
    }

    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa("Jo√£o", "123.456.789-10");
        
        // Imprimindo a inst√¢ncia da classe Pessoa
        System.out.println(pessoa);
    }
}


Neste exemplo, a classe `Pessoa` possui dois atributos: `nome` e `cpf`. O m√©todo `toString` √© sobrescrito para retornar uma representa√ß√£o personalizada da pessoa, incluindo o nome e o CPF. Ao criar uma inst√¢ncia da classe `Pessoa` e imprimir essa inst√¢ncia, o m√©todo `toString` personalizado √© chamado automaticamente, fornecendo uma representa√ß√£o textual mais √∫til da pessoa.

---
</br>
 
<h1 align="center"> üçÄ Dia 3 </h1>

<h2> üíª Exerc√≠cios</h2>

### ‚û°Ô∏è Pasta Rectangle

Nessa aula, foram abordados:

1. **Classes e Objetos**: A defini√ß√£o da classe `Rectangle` representa um modelo para criar objetos ret√¢ngulo. A inst√¢ncia dessa classe (`rectangle`) √© utilizada para realizar c√°lculos e armazenar dados.

2. **Encapsulamento**: Os membros de dados (`width` e `height`) da classe `Rectangle` foram declarados como p√∫blicos para simplificar o exemplo, mas em aplica√ß√µes reais, √© uma boa pr√°tica encapsular esses membros, tornando-os privados e fornecendo m√©todos p√∫blicos para acess√°-los e modific√°-los.

3. **M√©todos**: Os m√©todos na classe `Rectangle` (`area()`, `perimeter()`, `diagonal()`) realizam c√°lculos espec√≠ficos com os dados do ret√¢ngulo. Isso promove o re√∫so de c√≥digo e a organiza√ß√£o das funcionalidades.

4. **Entrada de Dados**: O uso da classe `Scanner` para obter entrada do usu√°rio via teclado.

5. **Sa√≠da Formatada**: A formata√ß√£o da sa√≠da usando o m√©todo `String.format()` para garantir que os resultados sejam exibidos de maneira clara e leg√≠vel.

6. **Utiliza√ß√£o de Bibliotecas Padr√£o**: O uso da classe `Math` para calcular a diagonal do ret√¢ngulo usando o teorema de Pit√°goras (`Math.sqrt()`).

7. **Padr√µes de Codifica√ß√£o**: A utiliza√ß√£o de conven√ß√µes de nomenclatura padr√£o (como camelCase para nomes de vari√°veis e m√©todos) e organiza√ß√£o do c√≥digo em blocos e m√©todos.

### ‚û°Ô∏è Pasta Funcionarios

Nesta aula, desenvolvemos um programa em Java para gerenciar informa√ß√µes de funcion√°rios e calcular sal√°rios l√≠quidos. Aqui est√° um resumo do que foi feito:

1. **Configura√ß√£o do Ambiente**: Utilizamos a classe `Locale` para configurar o local padr√£o para formata√ß√£o de n√∫meros decimais, garantindo consist√™ncia na exibi√ß√£o dos valores.

2. **Entrada de Dados**: Utilizamos a classe `Scanner` para receber entrada do usu√°rio via teclado, solicitando e armazenando informa√ß√µes como nome, sal√°rio bruto e imposto do funcion√°rio.

3. **Manipula√ß√£o de Objetos**: Criamos uma classe `Employee` para representar um funcion√°rio, com atributos para nome, sal√°rio bruto e imposto. Instanciamos um objeto dessa classe para armazenar os dados do funcion√°rio.

4. **C√°lculo do Sal√°rio L√≠quido**: Implementamos um m√©todo na classe `Employee` para calcular o sal√°rio l√≠quido do funcion√°rio, subtraindo o valor do imposto do sal√°rio bruto.

5. **Aumento de Sal√°rio**: Criamos um m√©todo na classe `Employee` para aumentar o sal√°rio do funcion√°rio com base em uma porcentagem fornecida pelo usu√°rio.

6. **Sa√≠da Formatada**: Utilizamos o m√©todo `toString()` na classe `Employee` para formatar os dados do funcion√°rio em uma string leg√≠vel, incluindo o nome e o sal√°rio l√≠quido.

7. **Interatividade com o Usu√°rio**: Solicitamos ao usu√°rio uma porcentagem para aumentar o sal√°rio do funcion√°rio e exibimos os dados atualizados do funcion√°rio, incluindo o novo sal√°rio l√≠quido.

8. **Boas Pr√°ticas de Programa√ß√£o**: Utilizamos coment√°rios para documentar o c√≥digo e fechamos o objeto `Scanner` para evitar vazamentos de recursos.


### ‚û°Ô∏è Pasta Alunos
Nesta aula, desenvolvemos um programa em Java para calcular a nota final de um aluno e determinar se ele foi aprovado ou reprovado. Aqui est√° um resumo do que foi feito:

1. **Configura√ß√£o do Ambiente**: Utilizamos a classe `Locale` para configurar o local padr√£o como US, garantindo a formata√ß√£o correta dos n√∫meros decimais.

2. **Entrada de Dados**: Utilizamos a classe `Scanner` para receber entrada do usu√°rio via console, solicitando e armazenando o nome do aluno e suas tr√™s notas.

3. **Manipula√ß√£o de Objetos**: Criamos uma classe `Student` para representar um aluno, com atributos para nome e notas. Instanciamos um objeto dessa classe para armazenar os dados do aluno.

4. **C√°lculo da Nota Final**: Implementamos um m√©todo na classe `Student` para calcular a nota final do aluno, somando suas tr√™s notas.

5. **Verifica√ß√£o de Aprova√ß√£o**: Utilizamos o m√©todo `notaFinal()` para determinar se o aluno foi aprovado ou reprovado. Se a nota final for menor que 60, o aluno √© considerado reprovado, caso contr√°rio, √© considerado aprovado.

6. **Mensagens de Sa√≠da**: Exibimos a nota final do aluno e uma mensagem indicando se ele foi aprovado ou reprovado. Se reprovado, tamb√©m exibimos a quantidade de pontos que faltam para atingir a nota m√≠nima de aprova√ß√£o.

7.  **Boas Pr√°ticas de Programa√ß√£o**: Utilizamos coment√°rios para documentar o c√≥digo e fechamos o objeto `Scanner` para evitar vazamentos de recursos.

---
</br>
<h1 align="center"> üçÄ Dia 4 </h1>


## üîó  OBJETOS S√ÉO ACESSADOS POR REFER√äNCIAS

Quando declaramos uma vari√°vel para associar a um objeto, na verdade, essa vari√°vel n√£o guarda o
objeto, mas, sim, uma maneira de acess√°-lo, chamada de refer√™ncia. √â por esse motivo que, diferente dos tipos primitivos como int e long, precisamos dar `new` depois de declarada a vari√°vel:

```java
public static void main(String[] args) {
    Conta c1;
    c1 = new Conta();
    Conta c2;
    c2 = new Conta();
}
```

O correto aqui √© dizer que `c1` se refere a um objeto. N√£o √© certo dizer que `c1` √© um objeto, pois `c1` √© uma vari√°vel refer√™ncia, apesar de, depois de um tempo, os programadores Java falarem: "tenho um objeto `c` do tipo `Conta`" como um modo para encurtar a frase: "tenho uma refer√™ncia `c` a um objeto do tipo `Conta`".

Basta lembrar que, em Java, uma vari√°vel nunca √© um objeto. N√£o h√°, no Java, uma maneira de criarmos o que √© conhecido como objeto pilha ou objeto local, pois todo objeto, nessa linguagem, sem exce√ß√£o, √© acessado por uma vari√°vel refer√™ncia.

Esse c√≥digo nos deixa na seguinte situa√ß√£o:

```java
Conta c1;
c1 = new Conta();
Conta c2;
c2 = new Conta();
```

Internamente, `c1` e `c2` v√£o guardar um n√∫mero que identifica em que posi√ß√£o da mem√≥ria aquela `Conta` se encontra. Dessa maneira, ao utilizarmos o "." para navegar, o Java acessar√° a `Conta` que se encontra naquela posi√ß√£o de mem√≥ria, e n√£o uma outra.

Para quem conhece, √© parecido com um ponteiro. Por√©m, voc√™ n√£o pode manipul√°-lo como um n√∫mero nem utiliz√°-lo para aritm√©tica, pois ela √© tipada.

Um outro exemplo:

```java
class TestaReferencias {
    public static void main(String[] args) {
        Conta c1 = new Conta();
        c1.deposita(100);
        Conta c2 = c1; // linha importante!
        c2.deposita(200);
        System.out.println(c1.saldo);
        System.out.println(c2.saldo);
    }
}
```

Qual √© o resultado do c√≥digo acima? O que aparece ao rodar?

O que acontece aqui? O operador `=` copia o valor de uma vari√°vel. Mas qual √© o valor da vari√°vel `c1`? √â o objeto? N√£o. Na verdade, o valor guardado √© a refer√™ncia (endere√ßo) ao local onde o objeto se encontra na mem√≥ria principal.

Na mem√≥ria, o que acontece nesse caso:

```java
Conta c1 = new Conta();
Conta c2 = c1;
```

Quando fizemos `c2 = c1`, `c2` passa, nesse instante, a fazer refer√™ncia ao mesmo objeto referenciado por `c1`.

Ent√£o, nesse c√≥digo em espec√≠fico, quando utilizamos `c1` ou `c2`, estamos nos referindo exatamente ao mesmo objeto! Elas s√£o duas refer√™ncias distintas, por√©m apontam para o mesmo objeto. Compar√°-las com `==` ir√° nos retornar `true`, pois o valor que elas carregam √© o mesmo!

Outra forma de perceber isso √© que demos apenas um `new`, logo s√≥ pode haver um objeto `Conta` na mem√≥ria.

Aten√ß√£o: n√£o estamos discutindo aqui a utilidade de fazer uma refer√™ncia apontar para o mesmo objeto que outra. Essa utilidade ficar√° mais evidente quando passarmos vari√°veis do tipo refer√™ncia como argumento a m√©todos.

## üîó NEW

O que exatamente faz o `new`?

O `new` executa uma s√©rie de tarefas que veremos mais adiante.

Mas, a fim de melhor entender as refer√™ncias no Java, imagine que o `new`, depois de alocar a mem√≥ria para esse objeto, devolve uma flecha, isto √©, um valor de refer√™ncia. Quando voc√™ atribui isso a uma vari√°vel, essa vari√°vel passa a se referir a esse mesmo objeto.

Podemos, ent√£o, ver outra situa√ß√£o:

```java
public static void main(String[] args) {
    Conta c1 = new Conta();
    c1.titular = "Duke";
    c1.saldo = 227;
    Conta c2 = new Conta();
    c2.titular = "Duke";
    c2.saldo = 227;
    if (c1 == c2) {
        System.out.println("Contas iguais");
    }
}
```

O operador `==` compara o conte√∫do das vari√°veis, mas essas vari√°veis n√£o guardam o objeto, e sim o endere√ßo em que ele se encontra. Como em cada uma dessas vari√°veis guardamos duas contas criadas diferentemente, elas est√£o em espa√ßos distintos da mem√≥ria, o que faz o teste `if` valer `false`. As contas podem ser equivalentes no nosso crit√©rio de igualdade, por√©m elas n√£o s√£o o mesmo objeto.

Quando se trata de objetos, pode ficar mais f√°cil pensar que o `==` compara se os objetos (refer√™ncias, na verdade) s√£o o mesmo, e n√£o se s√£o iguais. Para saber se dois objetos t√™m o mesmo conte√∫do, voc√™ precisa comparar atributo por atributo. Veremos uma solu√ß√£o mais elegante para isso tamb√©m.

</br>

<h1 align="center"> üçÄ Dia 5 </h1>

##  üîó  Membros est√°ticos

- Tamb√©m chamados membros de classe
- Em oposi√ß√£o a membros de inst√¢ncia
- S√£o membros que fazem sentido independentemente de objetos. N√£o precisam de objeto para serem chamados. S√£o chamados a partir do pr√≥prio nome da classe.
- Aplica√ß√µes comuns:
  - Classes utilit√°rias
  - Declara√ß√£o de constantes
- Uma classe que possui somente membros est√°ticos, pode ser uma classe est√°tica tamb√©m. Esta classe n√£o poder√° ser instanciada

Vamos simplificar. Pense em uma classe como uma receita para criar objetos. Os membros s√£o as "partes" dessa receita: vari√°veis e m√©todos.

Agora, considere que voc√™ tem uma classe chamada `Carro`. Esta classe tem membros, como `cor` e `velocidadeMaxima`. Quando voc√™ cria um objeto dessa classe, como `meuCarro`, ele ter√° sua pr√≥pria cor e velocidade m√°xima.

Mas, √†s vezes, voc√™ tem algo relacionado √† classe como um todo, n√£o a uma inst√¢ncia espec√≠fica. Por exemplo, voc√™ pode querer saber a quantidade total de carros criados, ou uma funcionalidade que n√£o dependa de um carro em particular.

Aqui √© onde entram os membros est√°ticos. Eles s√£o membros da classe em si, n√£o de uma inst√¢ncia espec√≠fica. Assim, todos os objetos da classe compartilham o mesmo valor para um membro est√°tico.

Por exemplo, digamos que voc√™ queira saber a quantidade total de carros criados. Em vez de rastrear isso individualmente para cada carro, voc√™ pode ter um membro est√°tico na classe `Carro`, chamado `quantidadeTotalDeCarros`.

Essa √© uma maneira de ver membros est√°ticos: como pertencendo √† classe em si, em vez de a inst√¢ncias individuais dessa classe. Isso significa que voc√™ pode acess√°-los sem precisar criar um objeto da classe.
 
<h3> Problema exemplo:</h3>
Fazer um programa para ler um valor num√©rico qualquer, e da√≠ mostrar quanto seria o valor de uma circunfer√™ncia e do volume de uma esfera para um raio daquele valor. Informar tamb√©m o valor de PI com duas casas decimais.

- Vers√£o 1: m√©todos na pr√≥pria classe do programa
  - Nota: dentro de um m√©todo est√°tico voc√™ n√£o pode chamar membros de inst√¢ncia da mesma classe.
- Vers√£o 2: classe Calculator com membros de inst√¢ncia
- Vers√£o 3: classe Calculator com m√©todo est√°tico

VERS√ÉO 1
```java
package application;
import java.util.Locale;
import java.util.Scanner;
public class Program {
    public static final double PI = 3.14159;
    public static void main(String[] args) {
        Locale.setDefault(Locale.US);
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter radius: ");
        double radius = sc.nextDouble();
        double c = circumference(radius);
        double v = volume(radius);
        System.out.printf("Circumference: %.2f%n", c);
        System.out.printf("Volume: %.2f%n", v);
        System.out.printf("PI value: %.2f%n", PI);
        sc.close();
    }
    public static double circumference(double radius) {
        return 2.0 * PI * radius;
    }
    public static double volume(double radius) {
        return 4.0 * PI * radius * radius * radius / 3.0;
    }
}

```

VERS√ÉO 2
```java
package util;
public class Calculator {
    public final double PI = 3.14159;
    public double circumference(double radius) {
        return 2.0 * PI * radius;
    }
    public double volume(double radius) {
        return 4.0 * PI * radius * radius * radius / 3.0;
    }
}
```
```java
Calculator calc = new Calculator();
System.out.print("Enter radius: ");
double radius = sc.nextDouble();
double c = calc.circumference(radius);
double v = calc.volume(radius);
System.out.printf("Circumference: %.2f%n", c);
System.out.printf("Volume: %.2f%n", v);
System.out.printf("PI value: %.2f%n", calc.PI);
```

VERS√ÉO 3
```java
System.out.print("Enter radius: ");
double radius = sc.nextDouble();
double c = Calculator.circumference(radius);
double v = Calculator.volume(radius);
System.out.printf("Circumference: %.2f%n", c);
System.out.printf("Volume: %.2f%n", v);
System.out.printf("PI value: %.2f%n", Calculator.PI);
```
